class Solution {
public:
    vector<int>parent;
    vector<int>rank;
    vector<int>infected;
    int find(int node){
        while(node!= parent[node]){
            node = parent[node];
        }
        
        return node;
    }
    void Union(int i, int j){
        int iParent = find(i);
        int jParent = find(j);
        
        if(rank[iParent] < rank[jParent]){
            parent[iParent] = jParent;
            rank[jParent]+= rank[iParent] ;
        }else if(rank[iParent]>rank[jParent]){
            parent[jParent]= iParent;
            rank[iParent]+= rank[jParent];
        }else{
            parent[jParent]= iParent;
            rank[iParent]+= rank[jParent];
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // Let us use the concept of Union find
        int n = graph.size();
        // rank is initialised to 1 as each DSU is at least of size 1 
        rank.resize(n, 1);
        parent.resize(n);
        infected.resize(n, 0);
        // Let us initialise the parent
        
        for(int i=0; i<n; i++){
            parent[i]= i;
        }
        // Now first let us union what all we can union
        // After union we will have Disjoint sets which can be used for further processing
        
        for(int i=0; i<graph.size(); i++){
            for(int j=0; j<graph[0].size(); j++){
                if(graph[i][j]==1){
                    // Meaning node 0 can be connected to node j
                    if(find(i)!= find(j)){
                        // They can be unioned
                        Union(i, j);
                    }
                }
            }
        }
        
        
        // Now we have DSU
        
        // Now we will identify which root is infected most
        
        
       
        
        // Let us store the initial 
        // We might need to return it when we yield nothing after procesing
        
        
        
       for(auto i: initial){
            int par = find(i);
            infected[par]++;
        }
        
        
        // Now that we found which root is infected and let us try to remove that node from initial so that the size of DSU would be maximised 
        // and we will remove that node from a maximum sized DSU
        
        int ansSize = -1;
        int node = -1;
        
        
        for(auto i: initial){
            int par = find(i);
            if(infected[par] == 1){ 
                int sizeOfSet = rank[par];
           
                if(sizeOfSet > ansSize){
                    // Meaning if we remove this node we can have a maximum sized DSU
                    ansSize = sizeOfSet;
                    node= i;
                }else if(sizeOfSet == ansSize and i < node){
                    node = i;
                    ansSize == sizeOfSet;
                }
            }
        }
        
        
        // We may end up with -1 in node so we return the minimum in initials
        
        if(node==-1){
            node = INT_MAX;
                
            for(auto i: initial){
                node = min(node, i);
            }
        }
        
        return node;
        
        
        
        
    }
};

class Solution {
public:

    class DSU{
        public:
        vector<int>parent;
        vector<int>rank;
        DSU(int n){
            rank.resize(n, 1);
            parent.resize(n);

            iota(begin(parent), end(parent), 0);
        }

        void Union(int i, int j){
            int iParent = find(i);
            int jParent = find(j);

            if(find(i)==find(j)){
                return;
            }
            if(rank[iParent]>rank[jParent]){
                rank[iParent]+=rank[jParent];
                parent[jParent] = iParent;
            }else{
                rank[jParent]+=rank[iParent];
                parent[iParent]= jParent;
            }
        }


        int find(int node){
            while(node!=parent[node]){
                node = parent[node];
            }

            return node;
        }
    };
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {

        int n = graph.size();
        DSU* a = new DSU(n);

        // Let us Union all the components without nodes from initial

        vector<int> infected(n);
        for(int i:initial){
            infected[i] = 1;
        
        }

        for(int i =0; i<n; i++){
            if(infected[i]==0){
                for(int j =0; j<n; j++){
                    if(infected[j]==0){
                        // So we are taking only those edges which are not infected

                        if(graph[i][j] == 1){
                            a->Union(i, j);
                        }
                    }
                }
            }
            
        }


        // Now that we have components;
        // SO we need to remove only one node;
        // Hence we see what all the components can have only of the infected node


        // So to do that let us try to find a set of components which can be attajched to this infected nodes


        map<int, set<int>>nodeToComponent;

        for(int i=0; i<n; i++){
            if(infected[i] == 1){
                // Meaning this node is infected
                for(int j =0; j<n; j++){
                    if(infected[j] == 0){
                        // We want to process all infected nodes hence dont take both infected nodes at once
                    // So if there is an edge between i and j then the infected node can be attached to the compoonent

                        if(graph[i][j] == 1){
                            nodeToComponent[i].insert(a->find(j));
                        }
                    }
                }

            }
        }


        // Now we have identified which nodes can be attached to which components
        // So the set contains the parents of the components
        // So we loop through these sets and try to increment their infected count


        vector<int>count(n, 0);
        for(auto& [node, set]: nodeToComponent){
            for(int parentNodeOfComponent: set){
                count[parentNodeOfComponent]++;
            }
        }


        // Now let us loop through the map

        int ansSize = -1;
        int ansNode = -1;

        for(auto& [node, set]: nodeToComponent){
            int size = 0;
            for(int parentNodeOfComponent: set){
                if(count[parentNodeOfComponent] == 1){
                    // Meaning this can be a potential one

                    size+= a->rank[parentNodeOfComponent];
                }
            }


            if((size > ansSize)  or (size == ansSize and node < ansNode)){
                ansSize = size;
                ansNode = node;
            }
        }



        // if ansNode is still -1 then we will return the one with smallest index
        if(ansNode==-1){
            ansNode = INT_MAX;

            for(int i: initial){
                ansNode = min(ansNode, i);
            }

        }


        return ansNode;
    }
};
