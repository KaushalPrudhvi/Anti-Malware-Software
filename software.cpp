class Solution {
public:
    vector<int>parent;
    vector<int>rank;
    vector<int>infected;
    int find(int node){
        while(node!= parent[node]){
            node = parent[node];
        }
        
        return node;
    }
    void Union(int i, int j){
        int iParent = find(i);
        int jParent = find(j);
        
        if(rank[iParent] < rank[jParent]){
            parent[iParent] = jParent;
            rank[jParent]+= rank[iParent] ;
        }else if(rank[iParent]>rank[jParent]){
            parent[jParent]= iParent;
            rank[iParent]+= rank[jParent];
        }else{
            parent[jParent]= iParent;
            rank[iParent]+= rank[jParent];
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // Let us use the concept of Union find
        int n = graph.size();
        // rank is initialised to 1 as each DSU is at least of size 1 
        rank.resize(n, 1);
        parent.resize(n);
        infected.resize(n, 0);
        // Let us initialise the parent
        
        for(int i=0; i<n; i++){
            parent[i]= i;
        }
        // Now first let us union what all we can union
        // After union we will have Disjoint sets which can be used for further processing
        
        for(int i=0; i<graph.size(); i++){
            for(int j=0; j<graph[0].size(); j++){
                if(graph[i][j]==1){
                    // Meaning node 0 can be connected to node j
                    if(find(i)!= find(j)){
                        // They can be unioned
                        Union(i, j);
                    }
                }
            }
        }
        
        
        // Now we have DSU
        
        // Now we will identify which root is infected most
        
        
       
        
        // Let us store the initial 
        // We might need to return it when we yield nothing after procesing
        
        
        
       for(auto i: initial){
            int par = find(i);
            infected[par]++;
        }
        
        
        // Now that we found which root is infected and let us try to remove that node from initial so that the size of DSU would be maximised 
        // and we will remove that node from a maximum sized DSU
        
        int ansSize = -1;
        int node = -1;
        
        
        for(auto i: initial){
            int par = find(i);
            if(infected[par] == 1){ 
                int sizeOfSet = rank[par];
           
                if(sizeOfSet > ansSize){
                    // Meaning if we remove this node we can have a maximum sized DSU
                    ansSize = sizeOfSet;
                    node= i;
                }else if(sizeOfSet == ansSize and i < node){
                    node = i;
                    ansSize == sizeOfSet;
                }
            }
        }
        
        
        // We may end up with -1 in node so we return the minimum in initials
        
        if(node==-1){
            node = INT_MAX;
                
            for(auto i: initial){
                node = min(node, i);
            }
        }
        
        return node;
        
        
        
        
    }
};
